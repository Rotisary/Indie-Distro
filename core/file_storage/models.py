import os, uuid

from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
from django.conf import settings
from django.db.models import JSONField

from core.utils.mixins import BaseModelMixin
from core.utils import enums
from core.users.models import User



class FileModel(BaseModelMixin):
    id = models.CharField(
        primary_key=True,
        blank=True, 
        null=False, 
        unique=True, 
        max_length=100
    )
    owner = models.ForeignKey(
        to=User,
        on_delete=models.CASCADE,
        null=False,
        blank=False,
        related_name="files",
        verbose_name=_("File Owner")
    )
    film = models.OneToOneField(
        to="feed.Feed",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="file",
        verbose_name=_("File Film"),
        help_text=_("The film related to the file")
    )
    file_purpose = models.CharField(
        choices=enums.FilePurposeType.choices(),
        null=False,
        blank=False,
        verbose_name=_("File purpose"),
        max_length=100
    )
    file_key = models.CharField(
        _("File Key"),
        null=True,
        blank=False,
        max_length=255,
        help_text=_("The file key in the storage provider")
    )
    mime_type = models.CharField(
        _("File MIME Type"),
        null=True,
        blank=True,
        max_length=100,
    )
    original_filename = models.CharField(
        _("Original File Name"),
        null=True,
        blank=True,
        max_length=500,
        editable=False,
    )
    is_verified = models.BooleanField(
        _("Is this file verified"),
        null=False,
        blank=True,
        default=False,
        editable=True,
    )  
    checksum = models.CharField(
        max_length=128, 
        null=True, 
        blank=True, 
        help_text=_("checksum for file integrity verification")
    )
    file_width = models.IntegerField(
        _("Width of File"), null=True, blank=True
    )
    file_height = models.IntegerField(
        _("Height of File"), null=True, blank=True
    )
    file_size = models.BigIntegerField(
        _("File Size in bytes"), null=True, blank=True
    )
    format_name = models.CharField(
        _("Format Name"), max_length=64, null=True, blank=True
    )
    has_audio = models.BooleanField(default=True)
    hls_master_key = models.CharField(
        _("HLS Master Key"), max_length=1024, null=True, blank=True
    )
    dash_mpd_key = models.CharField(
        _("Dash MPD Key"), max_length=1024, null=True, blank=True
    )
    last_error = models.TextField(
        _("Last Error During Processing"), null=True, blank=True
    )
    processing_status = models.CharField(
        _("Processing Status"),
        max_length=16, 
        choices=enums.JobStatus.choices(), 
        default=enums.JobStatus.PENDING.value
    )
    last_processed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name = _("File")
        verbose_name_plural = _("Files")


    @property
    def file_type(self):
        mimetype = self.mime_type
        return mimetype and mimetype.split("/")[0]
    

    # @property
    # def file_src(self):
    #     return (
    #         self.file.url
    #         if settings.USING_MANAGED_STORAGE
    #         else os.path.join(settings.BASE_DIR, self.file.path)
    #     )
    

    def __str__(self):
        return self.id
    

    # def save(self, *args, **kwargs):
    #     if not self.id:
    #         self.id = self.get_identifier()
    #     super().save(*args, **kwargs)


class FileProcessingJob(BaseModelMixin):
    owner = models.ForeignKey(
        "users.User", 
        on_delete=models.CASCADE, 
        related_name="processing_jobs",
        null=False
    )
    file = models.OneToOneField(
        to=FileModel,
        on_delete=models.CASCADE,
        related_name="jobs",
        null=False,
        verbose_name=_("File Being Processed")
    )
    source_key = models.CharField(
        max_length=1024, verbose_name=_("File Source Key")
    )
    source_checksum = models.CharField(
        max_length=128, 
        blank=True, 
        null=True,
        help_text=_("checksum generated by client during file upload")
    )
    status = models.CharField(
        max_length=32, 
        choices=enums.JobStatus.choices(), 
        default=enums.JobStatus.PENDING.value,
        help_text=_("The status of the file processing job")
    )
    current_stage = models.CharField(
        max_length=64, 
        choices=enums.Stage.choices(), 
        blank=True, 
        null=True,
        help_text=_("The current stage of the file processing job")
    )
    stages = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        verbose_name=_("Per stage details")
    )
    metadata = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        help_text=_("ffprobe result and extracted fields data")
    )
    renditions = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        help_text=_("list of produced renditions (keys, sizes e.t.c)")
    ) 
    packaging = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        help_text=_("hls and dash packaging results")
    )
    thumbnails = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        help_text=_("list of thumbnail keys")
    )
    audio = JSONField(
        default=dict, 
        blank=True, 
        null=True, 
        help_text=_("audio related outputs")
    )
    error = models.TextField(blank=True, null=True)


    class Meta:
        verbose_name = _("File Processing Job")
        verbose_name_plural = _("File Processing Jobs")


    def mark_stage(self, stage: str, data: dict = None):
        self.current_stage = stage
        self.status = enums.JobStatus.RUNNING.value
        s = self.stages or {}
        s[stage] = {
            **(s.get(stage) or {}), **(data or {}), 
            "ts": timezone.now().isoformat()
        }
        self.stages = s
        self.save(update_fields=["current_stage", "status", "stages", "date_last_modified"])


    def mark_failed(self, message: str):
        self.status = enums.JobStatus.FAILED.value
        self.error = message
        self.save(update_fields=["status", "error", "date_last_modified"])


    def mark_completed(self):
        self.status = enums.JobStatus.COMPLETED.value
        self.current_stage = enums.Stage.FINALIZE.value
        self.save(update_fields=["status", "current_stage", "date_last_modified"])


    def __str__(self):
        return f"ProcessingJob({self.id}) {self.source_key} [{self.status}]"
